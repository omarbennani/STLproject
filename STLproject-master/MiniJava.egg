----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;



inh tdsClasses		: SymbolTable for Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Type, TypeAtomique , SuiteTypeAtomique , Affectation, SuiteAffectation, Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Arguments, Acces, Appel,AppelOuAcces, Parametre, SuiteParametres, Parametres, Classe, HeritageClasse, ImplantationInterface, ElementsClasse, Classes, AttributOuMethode, SuiteAttributOuMethode, ElementClasse, Constructeur, Principale, MethodePrincipale, Instruction, Instructions, SuiteConditionnelle , Bloc, Genericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ArgumentGenericite;

--inh tdsClassesDeGenericite : SymbolTable for Type, TypeAtomique, ElementsClasse, ElementClasse 



inh tdsInterface	: SymbolTable for Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Type, TypeAtomique , SuiteTypeAtomique , Affectation, SuiteAffectation, Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Arguments, Acces, Appel, AppelOuAcces, Parametre, SuiteParametres, Parametres, Classe, HeritageClasse, ImplantationInterface, ElementsClasse, Classes, AttributOuMethode, SuiteAttributOuMethode, ElementClasse, Constructeur, Principale, MethodePrincipale, Instruction, Instructions, SuiteConditionnelle , Bloc , Genericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ArgumentGenericite;



inh tdsMethodes		: SymbolTableMethodes for Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Type, TypeAtomique , SuiteTypeAtomique , Affectation, SuiteAffectation, Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Arguments, Acces, Appel, AppelOuAcces, Parametre, SuiteParametres, Parametres, Classe, HeritageClasse, ImplantationInterface, ElementsClasse, Classes, AttributOuMethode, SuiteAttributOuMethode, ElementClasse, Constructeur, Principale, MethodePrincipale, Instruction, Instructions, SuiteConditionnelle , Bloc, Genericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ArgumentGenericite; -- Methodes statiques



inh tdsAttributs	: SymbolTable for Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Type, TypeAtomique , SuiteTypeAtomique , Affectation, SuiteAffectation, Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Arguments, Acces, Appel, AppelOuAcces, Parametre, SuiteParametres, Parametres, Classe, HeritageClasse, ImplantationInterface, ElementsClasse, Classes, AttributOuMethode, SuiteAttributOuMethode, ElementClasse, Constructeur, Principale, MethodePrincipale, Instruction, Instructions, SuiteConditionnelle , Bloc; --Attributs statiques



inh tds		: SymbolTable for Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Type, TypeAtomique , SuiteTypeAtomique , Affectation, SuiteAffectation, Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Arguments, Acces, Appel, AppelOuAcces, Parametre, SuiteParametres, Parametres, Classe, HeritageClasse, ImplantationInterface, ElementsClasse, Classes, AttributOuMethode, SuiteAttributOuMethode, ElementClasse, Constructeur, Principale, MethodePrincipale, Instruction, Instructions, SuiteConditionnelle , Bloc, ParametresGenericite, SuiteParametresGenericite; -- table des symboles -- table des symboles 

inh tds_Params 	: SymbolTable for Parametre, Parametres, SuiteParametres;

inh tdsMeth     : SymbolTableMethodes for Classe, ElementClasse, AttributOuMethode, SuiteAttributOuMethode, ElementsClasse;

inh tdsAtt      : SymbolTable for Classe, ElementClasse, ElementsClasse, Bloc, Facteur, SuiteAttributOuMethode, AttributOuMethode, Constructeur, Instruction, Instructions, SuiteConditionnelle, SuiteFacteur, Expression, Affectation, SuiteAffectation,Expressions, SuiteExpressions, SuiteNouveau, AppelOuAcces, Appel, Acces, Arguments, Terme, SuiteTerme, Condition, SuiteCondition;

inh factory	: BlockFactory for Interfaces, Interface, HeritageInterface, SuiteHeritageInterface, ElementsInterface, ElementInterface, Signature, Type, TypeAtomique , SuiteTypeAtomique , Affectation, SuiteAffectation, Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, SuiteNouveau, Arguments,Appel, Acces, AppelOuAcces, Parametre, SuiteParametres, Parametres, Classe, HeritageClasse, ImplantationInterface, ElementsClasse, Classes, DroitAcces, AttributOuMethode, SuiteAttributOuMethode, ElementClasse, Constructeur, Principale, MethodePrincipale, Instruction, Instructions, SuiteConditionnelle, Bloc, Genericite, ParametresGenericite, SuiteParametresGenericite, ParametreGenericite, HeritageGenericite, SuiteHeritageGenericite, InstanceGenericite, ArgumentsGenericite, SuiteArgumentsGenericite, ArgumentGenericite;

inh listHeritage: List<String> for SuiteHeritageInterface;
inh type	: Type for SuiteTypeAtomique ;

inh genericite 		:LinkedList<ParametreGenericite> for ElementsInterface, ElementInterface, ElementsClasse, ElementClasse, Bloc,Type, TypeAtomique , SuiteTypeAtomique, AttributOuMethode, SuiteAttributOuMethode, Constructeur, Instruction, Instructions, SuiteConditionnelle, Signature, Parametres, SuiteParametres, Parametre, Facteur, SuiteFacteur, Terme, SuiteTerme, Condition, SuiteCondition, Affectation, SuiteAffectation, Expression, Acces, Appel, AppelOuAcces,Expressions,  SuiteExpressions, SuiteNouveau, Arguments;

---------------------------------------------------------------------------------------------------------------
syn ast		: Programme for Programme ; 
syn ast		: LinkedList<Interface> for Interfaces;
syn ast		: LinkedList<ObjetUse> for HeritageInterface, SuiteHeritageInterface;
syn ast		: Interface for Interface;
syn ast		: LinkedList<ElementInterface> for ElementsInterface;
syn ast 	: ElementInterface for ElementInterface;
syn ast 	: Signature for Signature;
syn ast 	: Type for Type, TypeAtomique , SuiteTypeAtomique ;
syn bin_op	: BinaryOperator for Additif, Multiplicatif, Comparatif;

syn ast 	: Expression for Facteur, SuiteFacteur, SuiteNouveau,  Terme, SuiteTerme, Condition, SuiteCondition, Affectation, SuiteAffectation, Expression, Valeur, AppelOuAcces,Appel, Acces;

syn ast		: Expressions for Expressions, SuiteExpressions;
syn ast 	: Arguments for Arguments;

syn ast         : Parametre for Parametre;
syn ast         : LinkedList<Parametre> for Parametres, SuiteParametres;

inh gauche 	: Expression for SuiteAffectation, SuiteCondition, SuiteFacteur, SuiteTerme;

inh type 	: Type for SuiteNouveau;

syn ast 	: Classe for Classe;
syn ast 	: ObjetUse for HeritageClasse;
syn ast 	: LinkedList<ObjetUse> for ImplantationInterface;
syn ast 	: LinkedList<ElementClasse> for ElementsClasse;
syn ast 	: LinkedList<Classe> for Classes;

inh droit 	: DroitAcces for ElementClasse, AttributOuMethode, SuiteAttributOuMethode; 
inh nomAtt 	: String for SuiteAttributOuMethode;
inh nomClasse 	: String for ElementsClasse,ElementClasse, Constructeur, AttributOuMethode, SuiteAttributOuMethode;
inh typeAtt 	: Type for SuiteAttributOuMethode;
syn ast 	: DroitAcces for DroitAcces;
syn ast 	: ElementClasse for ElementClasse, AttributOuMethode, SuiteAttributOuMethode, Constructeur; 
syn ast 	: Block for Bloc;

inh type_Retour 	: Type for Bloc,SuiteAttributOuMethode, Instruction, SuiteConditionnelle, Instructions;

syn ast : MethodePrincipale for Principale, MethodePrincipale;

inh tree : List<Instruction> for Instructions;

syn insts : List<Instruction> for Instructions;

syn ast : Instruction for Instruction;

syn ast : Block for SuiteConditionnelle;

inh identificateur_type : String for AppelOuAcces, Appel, Acces;

inh identificateur : String for AppelOuAcces, Appel, Acces;

inh fromAcces : Boolean for AppelOuAcces, Appel, Acces;
inh fromFacteur : Boolean for AppelOuAcces, Appel, Acces;


syn typeElementClasse	: Integer for AttributOuMethode, SuiteAttributOuMethode;
inh support 	:Expression for Appel, Acces, AppelOuAcces;
--inh ident 		:String for Appel, Acces, AppelOuAcces;
--inh typeAcces 	:Integer for Acces, Appel, AppelOuAcces;
inh identObjetCourant 	: String for ElementsInterface, ElementInterface, Signature;
--inh decl		:Declaration for Acces, Appel, AppelOuAcces;
inh nomClasse		:String for Facteur, SuiteFacteur, Terme, SuiteTerme, Condition, SuiteCondition, Affectation, SuiteAffectation , Expression, SuiteNouveau, Acces, Instruction, Instructions,SuiteExpressions, Expressions, Arguments, Bloc, SuiteConditionnelle, AppelOuAcces, Appel;

syn ast         : ObjetUse for ArgumentGenericite;

--syn ast         : LinkedList<ArgumentGenericite> for ArgumentsGenericite, SuiteArgumentsGenericite, InstanceGenericite;
syn ast         : LinkedList<ObjetUse> for ArgumentsGenericite, SuiteArgumentsGenericite, InstanceGenericite;
syn ast		: LinkedList<Type> for HeritageGenericite, SuiteHeritageGenericite;

syn ast         : ParametreGenericite for ParametreGenericite;

syn ast         : LinkedList<ParametreGenericite> for ParametresGenericite, SuiteParametresGenericite, Genericite;


space  separateur				is    "[\n\r\t ]+";
space  commentaire			    is    "\/\/.*\n";
sugar  accolade_ouvrante		is    "\{";  
sugar  accolade_fermante		is    "\}";
sugar  crochet_ouvrant			is    "\[";  
sugar  crochet_fermant			is    "\]";  
sugar  parenthese_ouvrante		is    "\(";
sugar  parenthese_fermante		is    "\)";
sugar  inferieur				is    "\<";  
sugar  superieur				is    "\>";  
sugar  inferieur_egal			is    "\<=";  
sugar  superieur_egal			is    "\>=";  
sugar  point					is    "\.";
sugar  point_virgule			is    ";";  
sugar  virgule					is    ",";
sugar  affectation				is    "=";
sugar  egalite					is    "==";  
sugar  different				is    "\!=";  
sugar  addition				    is    "\+";
sugar  soustraction				is    "\-";
sugar  ou						is    "\|\|";  
sugar  multiplication			is    "\*";
sugar  division				    is    "/";
sugar  modulo					is    "%";
sugar  adresse					is    "&";  
sugar  negation				    is    "\!";  
sugar  et						is    "&&";  
sugar  vrai				    	is    "true";
sugar  faux					    is    "false";
sugar  si						is    "if";
sugar  sinon					is    "else";
sugar  afficher					is    "print";  
sugar  nouveau				    is    "new";  
sugar  tant_que				    is    "while";  
sugar  retour					is    "return";  
sugar  type_int				    is    "int";
sugar  type_bool				is    "boolean";  
sugar  type_char				is    "char";        
sugar  type_String				is    "String";        
sugar  vide					    is    "void";     
sugar  nul						is    "null";     
sugar  choix					is    "\?";         
sugar  deux_points				is    ":";          
sugar  interface				is    "interface";     
sugar  classe					is    "class";      
sugar  extension				is    "extends";      
sugar  implantation				is    "implements";      
sugar  public					is    "public";    
sugar  protege					is    "protected";
sugar  prive					is    "private";
sugar  statique					is    "static";
sugar  final				    is    "final";
sugar  principale				is    "main";
term   chaine					is    "\"([^\"]|\\\")*\"";
term   caractere				is    "\'[^\']\'";
term   entier					is    "[0-9]+";
term   identificateur			is    "[a-z_][a-zA-Z0-9_]*";
term   identificateur_type		is    "[A-Z][a-zA-Z0-9_]*"; 



Programme -> #inter Interfaces #class Classes #principal Principale #ast;
global
    s_clas : SymbolTable;
    s_intr : SymbolTable;
	s_meth: SymbolTableMethodes;
    s_att : SymbolTable;
#inter {
local
	c : Classe;
do
	s_intr := new SymbolTable();
    s_clas := new SymbolTable();
	s_meth := new SymbolTableMethodes();
	s_att := new SymbolTable();

	Interfaces^tdsInterface := s_intr;
    Interfaces^tdsClasses := s_clas;
	Interfaces^tdsMethodes := s_meth;
	Interfaces^tdsAttributs := s_att;

	c := new ClasseImpl("String", new LinkedList<ParametreGenericite>(), null, new LinkedList<ObjetUse>(), new 	LinkedList<ElementClasse>()  );
	s_clas.register(c);

	Interfaces^tds := new SymbolTable();

    Interfaces^factory := new BlockFactoryImpl();
end
}
#class {
do
	Classes^tdsInterface := s_intr;
    Classes^tdsClasses := s_clas;
	Classes^tdsMethodes := s_meth;
	Classes^tdsAttributs := s_att;

	Classes^tds := new SymbolTable();

    Classes^factory := new BlockFactoryImpl();
end
}
#principal {
do
	Principale^tdsInterface := s_intr;
    Principale^tdsClasses := s_clas;
	Principale^tdsMethodes := s_meth;
	Principale^tdsAttributs := s_att;

    Principale^tds := new SymbolTable();

    Principale^factory := new BlockFactoryImpl();
    s_meth.setClasseConstructeur(s_clas);
end
}

#ast {
do
    Programme^ast := new ProgrammeImpl(Interfaces^ast, Classes^ast, Principale^ast);
end
}




Interfaces ->  Interface #tds  Interfaces #ast;
#tds{
do
	Interfaces^tdsInterface.register(Interface^ast);
end
}

#ast{
do
	Interfaces1^ast.addFirst(Interface^ast);
	Interfaces^ast := Interfaces1^ast;
end
}



Interfaces -> #ast;
#ast{
do
	Interfaces^ast := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante #tds ElementsInterface accolade_fermante #ast;
#tds{
do
		ElementsInterface^tds := new SymbolTable();
		ElementsInterface^identObjetCourant := identificateur_type^txt;
		ElementsInterface^genericite := Genericite^ast;
end
}

#ast{
do
	Interface^ast := Interface^factory.createInterface(identificateur_type^txt,Genericite^ast, HeritageInterface^ast, ElementsInterface^ast);
end
}


HeritageInterface -> extension identificateur_type InstanceGenericite #tds SuiteHeritageInterface #ast;
#tds{
local
   l : List<String>;
do
	if (HeritageInterface^tdsInterface.contains(identificateur_type^txt)) then
		l := new LinkedList<String>();
		l.add(identificateur_type^txt);
		SuiteHeritageInterface^listHeritage := l;
	else
		error(Interface_undefined_ident, identificateur_type^txt);
	end	
end
}


#ast{
local
   f : Optional<Declaration>;
   d : Declaration;
   o : ObjetUse;
do
	f := HeritageInterface^tdsInterface.get(identificateur_type^txt);
	d := f.get();
	match d
      		with Interface then 
				o := HeritageInterface^factory.createInterfaceUse(d, InstanceGenericite^ast);
				SuiteHeritageInterface^ast.addFirst(o);
      	end
	HeritageInterface^ast := SuiteHeritageInterface^ast;

end
}


HeritageInterface -> #ast;
#ast{
do
	HeritageInterface^ast := new LinkedList<ObjetUse>();
end
}

SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite #tds SuiteHeritageInterface #ast;
#tds{
do
	if (SuiteHeritageInterface^tdsInterface.contains(identificateur_type^txt)) then
		SuiteHeritageInterface^listHeritage.add(identificateur_type^txt);
		SuiteHeritageInterface1^listHeritage := SuiteHeritageInterface^listHeritage;
	else
		error(Interface_undefined_ident, identificateur_type^txt);
	end	
end
}


#ast{
local
   f : Optional<Declaration>;
   d : Declaration;
   o : ObjetUse;
do
	f := SuiteHeritageInterface^tdsInterface.get(identificateur_type^txt);
	d := f.get();
	match d
      		with Interface then 
				o := SuiteHeritageInterface^factory.createInterfaceUse(d, InstanceGenericite^ast);
				SuiteHeritageInterface1^ast.addFirst(o);
      	end
	SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;

end
}


SuiteHeritageInterface -> #ast;
#ast{
do
	SuiteHeritageInterface^ast := new LinkedList<ObjetUse>();
end
}


ElementsInterface -> ElementInterface #tds ElementsInterface #ast;
#tds{
do
	--ElementsInterface^tds.register(ElementInterface^ast);
	ElementsInterface1^tds := ElementsInterface^tds;
end
}

#ast{
do
	ElementsInterface1^ast.addFirst(ElementInterface^ast);
	ElementsInterface^ast := ElementsInterface1^ast;
end
}

ElementsInterface ->  #ast;
#ast{
do
	ElementsInterface^ast := new LinkedList<ElementInterface>();
end
}

ElementInterface -> final statique Type identificateur affectation #tdsAtt Expression point_virgule #ast;
#tdsAtt{
do
	Expression^tdsAtt := new SymbolTable();
	Expression^nomClasse := "notClasse";
end
}
#ast{
local
	stf : StaticField;
do
	if (ElementInterface^tdsAttributs.knows(ElementInterface^identObjetCourant+"."+identificateur^txt)) then
		error(field_ident_already_defined, identificateur^txt);
	else
		
		stf := ElementInterface^factory.createStaticField(Type^ast, identificateur^txt, Expression^ast);
		stf.setFinal(true);
		ElementInterface^ast := stf;

		ElementInterface^tdsAttributs.register(stf, ElementInterface^identObjetCourant);
		
	end
end
}

ElementInterface ->  Signature point_virgule #ast;
#ast{
do
	ElementInterface^ast := Signature^ast;
	ElementInterface^tdsMethodes.registerSignature(Signature^ast.getName(), ElementInterface^identObjetCourant, Signature^ast.getParametres(), Signature^ast);

end
}

Signature -> vide identificateur parenthese_ouvrante #tds_Params Parametres parenthese_fermante #ast;
#tds_Params{
do
	Parametres^tds_Params := new SymbolTable();
end
}

#ast{
do
	if (Signature^tdsMethodes.containsSignature(identificateur^txt, Signature^identObjetCourant, Parametres^ast)) then
		error(Signature_ident_already_defined, identificateur^txt);
	else
		Signature^ast := Signature^factory.createSignature(identificateur^txt, Parametres^ast, Signature^identObjetCourant);
	end
end
}

Signature -> Type identificateur parenthese_ouvrante #tds_Params Parametres parenthese_fermante #ast;

#tds_Params{
do
	Parametres^tds_Params := new SymbolTable();
end
}

#ast{
do
	if (Signature^tdsMethodes.containsSignature(identificateur^txt, Signature^identObjetCourant, Parametres^ast)) then
		error(Signature_ident_already_defined, identificateur^txt);
	else
		Signature^ast := Signature^factory.createSignature(Type^ast, identificateur^txt, Parametres^ast, Signature^identObjetCourant);
	end
end
}


Classes -> #inh Classe #tree Classes #ast;
#inh {
do
    Classe^tdsMeth := new SymbolTableMethodes();
    Classe^tdsAtt := new SymbolTable(Classes^tds);
end
}

#ast{
do
	Classes1^ast.addFirst(Classe^ast);
    Classes^ast := Classes1^ast;
end
}

#tree {
local
    lm : List<Methode>;
    la : List<Attribut>;
do
    Classe^ast.setClasseElementsClasse();
	Classes^tdsClasses.register(Classe^ast);
    lm := Classe^ast.updateMethodes();
    la := Classe^ast.updateAttributs();
    Classes^tdsAttributs.registerAttributs(la);
    Classes^tdsMethodes.registerMethodes(lm);
    --Classes^tds.register(Classe^ast);
    --Classes1^tds := Classes^tds; --PASSAGE NON NECESSAIRE
end
}

Classes -> #ast;
#ast{
do
	Classes^ast := new LinkedList<Classe>();
end
}


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante #inh ElementsClasse accolade_fermante #ast;
#ast{
do
	if Classe^tdsClasses.contains(identificateur_type^txt) then
		error(Class_already_defined, identificateur_type^txt);
	elseif Classe^tdsInterface.contains(identificateur_type^txt) then
		error(Class_Interface_ident_conflict, identificateur_type^txt);
	else
		Classe^ast := Classe^factory.createClasse(identificateur_type^txt,Genericite^ast, HeritageClasse^ast, ImplantationInterface^ast, ElementsClasse^ast);
	end
end
}
#inh {
do
	ElementsClasse^genericite := Genericite^ast;
    ElementsClasse^nomClasse := identificateur_type^txt;
end
}

HeritageClasse -> extension identificateur_type InstanceGenericite #ast;
#ast{
local
    f : Optional<Declaration>;
    d : Declaration;
	h : Classe;
	o : ObjetUse;
do
	h := nil;
	o := nil;
	if HeritageClasse^tdsClasses.contains(identificateur_type^txt) then
        f := HeritageClasse^tdsClasses.get(identificateur_type^txt);
        d := f.get();
		match d
		with Classe then
			o := HeritageClasse^factory.createClasseUse(d, InstanceGenericite^ast);
		end
		HeritageClasse^ast := o;
	else
		error(CLASS_undefined_ident, identificateur_type^txt);
	end
end
}

HeritageClasse -> #ast;
#ast{
do
	HeritageClasse^ast := nil;
end
}

ImplantationInterface -> implantation identificateur_type InstanceGenericite #tds SuiteHeritageInterface #ast;
#tds{
local
   l : List<String>;
do
	if (ImplantationInterface^tdsInterface.contains(identificateur_type^txt)) then
		l := new LinkedList<String>();
		l.add(identificateur_type^txt);
		SuiteHeritageInterface^listHeritage := l;
	else
		error(Interface_undefined_ident, identificateur_type^txt);
	end	
end
}


#ast{
local
   f : Optional<Declaration>;
   d : Declaration;
   o : ObjetUse;
do
	f := ImplantationInterface^tdsInterface.get(identificateur_type^txt);
	d := f.get();
	match d
      		with Interface then 
				o := ImplantationInterface^factory.createInterfaceUse(d, InstanceGenericite^ast);
				SuiteHeritageInterface^ast.addFirst(o);
      	end
	ImplantationInterface^ast := SuiteHeritageInterface^ast;

end
}



ImplantationInterface -> #ast;
#ast{
do
	ImplantationInterface^ast := new LinkedList<ObjetUse>();
end
}






Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante #ast;
#ast{
local
    m : MethodePrincipale;
do
	if Principale^tdsClasses.contains(identificateur_type^txt) then
		error(already_defined_ident, identificateur_type^txt);
	elseif Principale^tdsInterface.contains(identificateur_type^txt) then
		error(already_defined_ident, identificateur_type^txt);
	else
		m := MethodePrincipale^ast;
		m.setIdentificateurType(identificateur_type^txt);
		Principale^ast := m;
	end
end
}


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante #tdsAtt Bloc #ast;
#tdsAtt{
do
	Bloc^tdsAtt := new SymbolTable();
	Bloc^nomClasse := "Main";
	Bloc^type_Retour := nil;
	Bloc^genericite := new LinkedList<ParametreGenericite>();
end
}

#ast{
do
	MethodePrincipale^ast := new MethodePrincipaleImpl(Bloc^ast);
end
}





ElementsClasse -> DroitAcces #droit ElementClasse ElementsClasse #ast;
#ast {
do
    ElementsClasse1^ast.addFirst(ElementClasse^ast);
    ElementsClasse^ast := ElementsClasse1^ast;
end
}
#droit {
do
    ElementClasse^droit := DroitAcces^ast;
end
}
  
ElementsClasse -> #ast;
#ast{
do
	ElementsClasse^ast := new LinkedList<ElementClasse>();
end
}
 

DroitAcces -> public #ast;
#ast {
do
    DroitAcces^ast := DroitAcces^factory.createDroitAcces(0);
end
}
 
DroitAcces -> protege #ast;
#ast {
do
    DroitAcces^ast := DroitAcces^factory.createDroitAcces(1);
end
}
 
DroitAcces -> prive #ast;
#ast {
do
    DroitAcces^ast := DroitAcces^factory.createDroitAcces(2);
end
}  
 

ElementClasse -> statique AttributOuMethode #ast;
#ast {
local
	a : ElementClasse;
do
    a := AttributOuMethode^ast;
    a.setStatic(true);

	ElementClasse^ast := a;

	if AttributOuMethode^typeElementClasse = 0 then
		ElementClasse^tdsAttributs.register(a, ElementClasse^nomClasse);
	--else
	--	ElementClasse^tdsMethodes.registerMethode(m^ast.getName(), ElementClasse^nomClasse, m^ast.getParametres(), m);
		
	end

end
}  
 
ElementClasse -> AttributOuMethode #ast;
#ast {
local
	a : ElementClasse;
do
    a := AttributOuMethode^ast;
    a.setStatic(false);

	ElementClasse^ast := a;

	if AttributOuMethode^typeElementClasse = 0 then
		ElementClasse^tdsAttributs.register(a, ElementClasse^nomClasse);
	--else
	--	ElementClasse^tdsMethodes.registerMethode(m^ast.getName(), ElementClasse^nomClasse, m^ast.getParametres(), m);
	end

end
} 

ElementClasse -> Constructeur #ast;
#ast {
do
    ElementClasse^ast := Constructeur^ast;
	match Constructeur^ast with Constructeur then 
    	ElementClasse^tdsMethodes.registerConstructeur(ElementClasse^nomClasse, Constructeur^ast.getParametres(), Constructeur^ast);
	end
	
end
}
   

AttributOuMethode -> Type identificateur #inh SuiteAttributOuMethode #ast;
#ast {
do
    AttributOuMethode^ast := SuiteAttributOuMethode^ast;
	AttributOuMethode^typeElementClasse := SuiteAttributOuMethode^typeElementClasse;
end
}
#inh {
do
    SuiteAttributOuMethode^nomAtt := identificateur^txt;
    SuiteAttributOuMethode^typeAtt := Type^ast;
    SuiteAttributOuMethode^type_Retour := Type^ast;
end
}


AttributOuMethode -> #factory vide identificateur parenthese_ouvrante Parametres parenthese_fermante #inh Bloc #ast;
global
    t : SymbolTable;
    this : Parametre;

#factory{
do
    t := new SymbolTable();    
	Parametres^tds_Params := t;
    this := AttributOuMethode^factory.createParametre("this");
    Bloc^type_Retour := nil; 
end
}
#ast {
local
    m : ElementClasse;
do
    m := AttributOuMethode^factory.createMethode(AttributOuMethode^droit, identificateur^txt, Parametres^ast, Bloc^ast, AttributOuMethode^nomClasse);
    m.setThis(this);
    AttributOuMethode^ast := m;
	
	match m with Methode then 
    	AttributOuMethode^tdsMeth.registerMethode(identificateur^txt, AttributOuMethode^nomClasse, Parametres^ast, m);
		AttributOuMethode^tdsMethodes.registerMethode(identificateur^txt, AttributOuMethode^nomClasse, Parametres^ast, m);
	end

	AttributOuMethode^typeElementClasse := 1;
end
}
#inh {
do
    Bloc^tds := t;
    Bloc^tds.register(this);
end
}


SuiteAttributOuMethode -> point_virgule #ast;
#ast {
local
    a : ElementClasse;
do
        if SuiteAttributOuMethode^tdsAtt.contains(SuiteAttributOuMethode^nomAtt) then
        error(CLASS_attribut_already_defined, SuiteAttributOuMethode^nomAtt);
    else
        a := SuiteAttributOuMethode^factory.createAttribut(SuiteAttributOuMethode^droit, SuiteAttributOuMethode^typeAtt, SuiteAttributOuMethode^nomAtt);
        SuiteAttributOuMethode^ast := a;
        SuiteAttributOuMethode^tdsAtt.register(a);
		SuiteAttributOuMethode^typeElementClasse := 0;
    end
end
}


SuiteAttributOuMethode -> #factory parenthese_ouvrante Parametres parenthese_fermante #inh Bloc #ast;
global
    t : SymbolTable;
    this : Parametre;

#factory{
do
    t := new SymbolTable();
    Parametres^tds_Params := t;
	Bloc^type_Retour := SuiteAttributOuMethode^type_Retour;
end
}
#inh {
do
    Bloc^tds := t;
    this := SuiteAttributOuMethode^factory.createParametre("this");
    Bloc^tds.register(this);
end
}
#ast {
local
    m : ElementClasse;
do
    m := SuiteAttributOuMethode^factory.createMethode(SuiteAttributOuMethode^droit, SuiteAttributOuMethode^typeAtt, SuiteAttributOuMethode^nomAtt, Parametres^ast, Bloc^ast, SuiteAttributOuMethode^nomClasse);
    m.setThis(this);
    SuiteAttributOuMethode^ast := m;

	match m with Methode then
    	SuiteAttributOuMethode^tdsMeth.registerMethode(SuiteAttributOuMethode^nomAtt, SuiteAttributOuMethode^nomClasse, Parametres^ast, m);
		SuiteAttributOuMethode^tdsMethodes.registerMethode(SuiteAttributOuMethode^nomAtt, SuiteAttributOuMethode^nomClasse, Parametres^ast, m);
	end

	SuiteAttributOuMethode^typeElementClasse := 1;
end
}

Constructeur -> #factory identificateur_type parenthese_ouvrante Parametres parenthese_fermante #inh Bloc #ast;
global
    t : SymbolTable;
    this : Parametre;
#factory{
do
    t := new SymbolTable();
	Parametres^tds_Params := t;
    this := Constructeur^factory.createParametre("this");

end
}
#inh {
do
    Bloc^tds := t;
	Bloc^type_Retour := nil;
    Bloc^tds.register(this);
end
}
#ast {
local
    c : ElementClasse;
do
    if Constructeur^nomClasse.equals(identificateur_type^txt) then
        c := Constructeur^factory.createConstructeur(identificateur_type^txt, Parametres^ast, Bloc^ast);
        c.setThis(this);
        Constructeur^ast := c;
    else
        error(CLASS_nom_constructeur_incorrect, identificateur_type^txt);
    end
end
}


Parametres -> #ast;
#ast{
do
	Parametres^ast := new LinkedList<Parametre>(); 
end
}

Parametres -> Parametre #tds SuiteParametres  #ast;
#ast {
do
    SuiteParametres^ast.addFirst(Parametre^ast);
    Parametres^ast := SuiteParametres^ast;
end
}
#tds {
do
    Parametres^tds_Params.register(Parametre^ast);
end
}


SuiteParametres -> #ast;
#ast {
do
    SuiteParametres^ast := new LinkedList<Parametre>();
end
}

SuiteParametres -> virgule Parametre #tds SuiteParametres #ast ;
#tds{
do
	SuiteParametres^tds_Params.register(Parametre^ast);
end
}

#ast {
do
    SuiteParametres1^ast.addFirst(Parametre^ast);
    SuiteParametres^ast := SuiteParametres1^ast;
end
}

Parametre -> Type identificateur #ast;
#ast{
do
	if Parametre^tds_Params.contains(identificateur^txt) then
		error(PARAM_already_defined, identificateur^txt);
	else
		Parametre^ast := Parametre^factory.createParametre(Type^ast, identificateur^txt);
	end
end
}

Type -> TypeAtomique #inh SuiteTypeAtomique #ast;
#inh{
do
	SuiteTypeAtomique^type := TypeAtomique^ast;
end
}

#ast{
do
	Type^ast := SuiteTypeAtomique^ast;
end
}


TypeAtomique -> type_bool #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createIntegerType(); 
end
}

TypeAtomique -> type_char #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createCharType();  
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
   TypeAtomique^ast := TypeAtomique^factory.createStringType();  
end
}


TypeAtomique -> identificateur_type InstanceGenericite #ast;
#ast{
local
	f : Optional<Declaration>;
   	d : Declaration;
	i : int;
do
	if TypeAtomique^tdsInterface.contains(identificateur_type^txt) then
		f:= TypeAtomique^tdsInterface.get(identificateur_type^txt);
		d:= f.get();
		match d 
			with Interface then
				TypeAtomique^ast:=TypeAtomique^factory.createInterfaceType(d, InstanceGenericite^ast);
			end
	elseif TypeAtomique^tdsClasses.contains(identificateur_type^txt) then
		f:= TypeAtomique^tdsClasses.get(identificateur_type^txt);
		d:= f.get();
		match d 
			with Classe then
				TypeAtomique^ast:=TypeAtomique^factory.createClassType(d, InstanceGenericite^ast);
			end
	elseif SymbolTable.checkIfGenericParameterIsdefined(identificateur_type^txt, TypeAtomique^genericite) then
			i := SymbolTable.getParameterIndex(identificateur_type^txt, TypeAtomique^genericite);
			TypeAtomique^ast:=TypeAtomique^factory.createGenericParameterType(TypeAtomique^genericite.get(i), InstanceGenericite^ast);
	else
		error(Identificateur_Type_undefined,identificateur_type^txt);
	end
end
}



SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique1^type := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^type);
end
}
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique1^ast;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^type;
end
}


--------------------------


Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast;
#ast {
do
    Bloc^ast := Bloc^factory.createBlock(Instructions^insts);
end
}
#inh {
do
    Instructions^tree := new ArrayList<Instruction>();
    Instructions^tds := new SymbolTable(Bloc^tds);
end
}

Instructions -> #ast;
#ast {
do
    Instructions^insts := Instructions^tree;
end
}

Instructions -> Instruction #tree Instructions #ast;
#ast {
do
    Instructions^insts := Instructions1^insts;
end
}
#tree {
do
    Instructions^tree.add(Instruction^ast);
    Instructions1^tree := Instructions^tree;
end
}


Instruction -> Type identificateur affectation #tds Expression point_virgule #ast;
#ast {
local
    v : VariableDeclaration;
do
    if Instruction^tds.knows(identificateur^txt) then
        error(variable_already_defined,identificateur^txt);
    else
        v := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast);
        Instruction^tds.register(v);
        Instruction^ast := v;
    end
    
end
}
#tds {
do
    Expression^tds := Instruction^tds;
end
}



Instruction ->  Expression point_virgule #ast; -- WARRRRNING
#ast {
do
	if  Expression^ast = nil then
			error(instruction_expression, "expression ast null");
	else
		match Expression^ast
		with Instruction then
		    Instruction^ast := Expression^ast;
		else
			error(instruction_expression, "Must be an instruction");
		end
	end
end
}


Instruction -> si parenthese_ouvrante Expression parenthese_fermante #tds2 Bloc #tds3 SuiteConditionnelle #ast;
#ast {
do
    if (SuiteConditionnelle^ast = nil) then
        Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else
        Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
    end
end
}


#tds2 {
do
    Bloc^tds := Instruction^tds;
	Bloc^type_Retour := Instruction^type_Retour;
end
}
#tds3 {
do
    SuiteConditionnelle^tds := Instruction^tds;
end
}


SuiteConditionnelle -> #ast;
#ast {
do
    SuiteConditionnelle^ast := nil;
end
}

SuiteConditionnelle ->sinon #tds Bloc #ast;
#ast {
do
    SuiteConditionnelle^ast := Bloc^ast;
end
}
#tds {
do
    Bloc^tds := SuiteConditionnelle^tds;
	Bloc^type_Retour := SuiteConditionnelle^type_Retour;
end
}




Instruction -> tant_que parenthese_ouvrante #tds1 Expression parenthese_fermante #tds2 Bloc #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}
#tds1 {
do
    Expression^tds := Instruction^tds;
end
}
#tds2 {
do
    Bloc^tds := Instruction^tds;
	Bloc^type_Retour := Instruction^type_Retour;
end
}




Instruction -> afficher Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}



Instruction -> retour Expression point_virgule #ast;
#ast{
do
	Instruction^ast := Instruction^factory.createReturnInstruction(Expression^ast, 	Instruction^type_Retour);
end
}


Expressions -> Expression SuiteExpressions #ast ;
#ast{
do
	SuiteExpressions^ast.addExpression(Expression^ast);
	Expressions^ast := SuiteExpressions^ast;
end
}

SuiteExpressions -> virgule Expression SuiteExpressions  #ast;
#ast{
do
	SuiteExpressions1^ast.addExpression(Expression^ast);
	SuiteExpressions^ast := SuiteExpressions1^ast;
end
}

SuiteExpressions ->  #ast;
#ast{
do
	SuiteExpressions^ast := SuiteExpressions^factory.createExpressions();
end
}


Expression -> Affectation #gauche SuiteAffectation #ast;
#gauche{
do
	if Affectation^ast = nil then
		error(expression_affectation, "affectation ast should be not null");
	else
		SuiteAffectation^gauche := Affectation^ast;
	end
end
}

#ast{
do
	Expression^ast := SuiteAffectation^ast;
end
}


Affectation -> Condition #gauche SuiteCondition #ast;
#gauche{
do
	SuiteCondition^gauche := Condition^ast;
end
}

#ast{
do
	Affectation^ast := SuiteCondition^ast;
end
}

SuiteAffectation -> affectation Expression #ast;
#ast{
local
    vd : VariableDeclaration;
    va : Assignable;
    ad : Attribut;
    aa : Assignable;
    ae : Expression;
do
    match SuiteAffectation^gauche
        with VariableUseImpl then
            vd := SuiteAffectation^gauche.getVariableDeclaration();
            va := SuiteAffectation^factory.createVariableAssignment(vd);
	        SuiteAffectation^ast := SuiteAffectation^factory.createAssignment(va, Expression^ast);
        with AttributUseImpl then
            ad := SuiteAffectation^gauche.getAttribut();
            ae := SuiteAffectation^gauche.getExpression();
            aa := SuiteAffectation^factory.createAttributAssignment(ad, ae);
	        SuiteAffectation^ast := SuiteAffectation^factory.createAssignment(aa, Expression^ast);
    end
end
}

SuiteAffectation -> #ast;
#ast{
do
	SuiteAffectation^ast := SuiteAffectation^gauche;
end
}


SuiteCondition -> Comparatif  Condition  #ast;
#ast{
do
	SuiteCondition^ast := SuiteCondition^factory.createBinaryExpression( SuiteCondition^gauche, Comparatif^bin_op, Condition^ast);
end
}

SuiteCondition ->  #ast;
#ast{
do
	SuiteCondition^ast := SuiteCondition^gauche;
end
}


Condition -> Terme  #gauche SuiteTerme  #ast;
#gauche{
do
	SuiteTerme^gauche := Terme^ast;
end
}

#ast{
do
	Condition^ast := SuiteTerme^ast;
end
}


SuiteTerme -> Additif Terme #gauche SuiteTerme  #ast;  
#gauche {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(SuiteTerme^gauche,  Additif^bin_op,  Terme^ast);  
end 
}

#ast {
do 
   SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}


Terme -> Facteur  #gauche SuiteFacteur #ast ;
#gauche{
do
	SuiteFacteur^gauche := Facteur^ast;
end
}

#ast{
do
	Terme^ast := SuiteFacteur^ast;
end
}

SuiteFacteur -> Multiplicatif Facteur #gauche  SuiteFacteur #ast ;  
#gauche {
do
	SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(SuiteFacteur^gauche,  Multiplicatif^bin_op,  Facteur^ast);  
end 
}

#ast{
do
	SuiteFacteur^ast := SuiteFacteur1^ast;
end
}

SuiteFacteur -> #ast;  
#ast{
do
	SuiteFacteur^ast := SuiteFacteur^gauche;
end
}


Facteur -> accolade_ouvrante Expressions accolade_fermante  #ast;
#ast{
do
	Facteur^ast := Expressions^ast;
end
}
Facteur -> soustraction Facteur  #ast;
#ast{
do
	 Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end
}  

Facteur -> negation Facteur  #ast;
#ast{
do
	Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);
end
}   

Facteur -> Valeur #ast;
#ast{
do
	Facteur^ast := Valeur^ast;
end
}  

Facteur -> nouveau Type  #type SuiteNouveau  #ast;
#type{
do
	SuiteNouveau^type := Type^ast;
end
}

#ast{
do
	Facteur^ast := SuiteNouveau^ast;
end
}

Facteur -> parenthese_ouvrante Expression parenthese_fermante #ast;
#ast{
do
	Facteur^ast := Expression^ast;
end
}




SuiteNouveau -> crochet_ouvrant Expression crochet_fermant #ast;
#ast{
do
	SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);
end
}

SuiteNouveau -> Arguments #ast;
#ast{
do
	SuiteNouveau^ast := SuiteNouveau^factory.createObjetAllocation(SuiteNouveau^type, Arguments^ast);
end
}


Arguments -> parenthese_ouvrante parenthese_fermante #ast;
#ast{
do
	Arguments^ast := Arguments^factory.createArguments();
end
} 

Arguments -> parenthese_ouvrante Expressions parenthese_fermante  #ast;
#ast{
do
	Arguments^ast := Arguments^factory.createArguments(Expressions^ast);
end
}


Facteur -> identificateur_type point identificateur  #inh AppelOuAcces #ast;
#inh{
local
	o : Optional<Declaration>;
	d : Declaration;
	i : Interface;
	c : Classe;
do
	i := nil;
	c := nil;
	if Facteur^tdsClasses.contains(identificateur_type^txt) then
		o :=  Facteur^tdsClasses.get(identificateur_type^txt);
		d := o.get();
		match d with Classe then c := d; end
		
		AppelOuAcces^support := Facteur^factory.createClasseUse(c);
		AppelOuAcces^identificateur_type := identificateur_type^txt;
		AppelOuAcces^identificateur := identificateur^txt;

	elseif Facteur^tdsInterface.contains(identificateur_type^txt) then
		o :=  Facteur^tdsInterface.get(identificateur_type^txt);
		d := o.get();
		match d with Interface then i := d; end
		
		AppelOuAcces^support := Facteur^factory.createInterfaceUse(i);
		AppelOuAcces^identificateur_type := identificateur_type^txt;
		AppelOuAcces^identificateur := identificateur^txt;
	else
		error(NOT_DEFINED_CLASS_OR_INTERFACE, identificateur_type^txt);
	end
    AppelOuAcces^nomClasse := identificateur_type^txt;
    AppelOuAcces^fromAcces := true;
    AppelOuAcces^fromFacteur := true;
end
}

#ast{
do
	Facteur^ast := AppelOuAcces^ast;
end
}

Facteur -> identificateur #inh  AppelOuAcces #ast;
#inh
{
local
    d : Declaration;
	o : Optional<Declaration>;
	v : VariableDeclaration;
    p : Parametre;
	a : Attribut;
	s : StaticField;
    this : Expression;
    cu : ObjetUse;
do
    a := nil;
	v := nil;
    p := nil;
    s := nil;
    AppelOuAcces^fromFacteur := true;
    AppelOuAcces^fromAcces := false;
	AppelOuAcces^support := nil;
	AppelOuAcces^identificateur_type := nil;
	AppelOuAcces^identificateur := identificateur^txt;
    if Facteur^tds.knows(identificateur^txt) then
		o := Facteur^tds.get(identificateur^txt);
		d := o.get();
		match d
            with VariableDeclaration then v := d;
            with Parametre then p := d;
        end
		
        if p = nil then
		    AppelOuAcces^support := Facteur^factory.createVariableUse(v);
        else
            AppelOuAcces^support := Facteur^factory.createParametreUse(p);
        end

	elseif Facteur^tdsAttributs.contains(identificateur^txt, Facteur^nomClasse) then
		o := Facteur^tdsAttributs.get(Facteur^nomClasse + "." + identificateur^txt);
		d := o.get();
		match d
        with Attribut then a := d;
        with StaticField then s := d;
        end
        if a != nil then
            if (a.isStatic()) then
                AppelOuAcces^support := Facteur^factory.createAttributUse(a);
            else
                o := Facteur^tds.get("this");
                d := o.get();
                match d
                with Parametre then
                    this := Facteur^factory.createParametreUse(d);
		            AppelOuAcces^support := Facteur^factory.createAttributUse(a, this);
                end
            end
        else
            AppelOuAcces^support := s.getValue();
        end
	end
end
}

#ast{
do
	Facteur^ast := AppelOuAcces^ast;
end
}

AppelOuAcces -> #inh Acces #ast;
#inh{
local
    d : Declaration;
    o : Optional<Declaration>;
    a : Attribut;
    sf : StaticField;
	allAcces : boolean;
do
    a := nil;
    sf := nil;
    Acces^fromFacteur := false;
    if AppelOuAcces^fromAcces then
        if AppelOuAcces^tdsAttributs.contains(AppelOuAcces^identificateur, AppelOuAcces^nomClasse) then
		    o := AppelOuAcces^tdsAttributs.get(AppelOuAcces^nomClasse + "." + AppelOuAcces^identificateur);
		    d := o.get();
		    match d
                with Attribut then a := d;
                with StaticField then sf := d;
            end
            if a != nil then
				match AppelOuAcces^support
					with ParametreUseImpl then allAcces := true;
					else allAcces := false;
				end

				if (a.getDroitAcces() = DroitAcces.publique || allAcces) && !a.isStatic() then
					Acces^support := AppelOuAcces^factory.createAttributUse(a, AppelOuAcces^support);
				elseif a.isStatic() then
					match AppelOuAcces^support
						with ClasseUseImpl then 
							Acces^support := AppelOuAcces^factory.createAttributUse(a, AppelOuAcces^support);
						else
							error(ACCESS_FORBIDDEN, " You must acces a static field through The class");
					end
				else
					error(ACCESS_FORBIDDEN, " Acces to a private or a protected attribute is forbidden");
				end
            else
				match AppelOuAcces^support
					with InterfaceUseImpl then 
						Acces^support := sf.getValue();
					else
						error(ACCESS_FORBIDDEN, " You must acces a static field through The class or the interface");
				end
                
            end
	    end

        Acces^fromAcces := false;
    else
        Acces^support := AppelOuAcces^support;
    end
end
}

#ast{
do
	AppelOuAcces^ast := Acces^ast;
end
}

AppelOuAcces -> Appel #ast;
#ast{
do
	AppelOuAcces^ast := Appel^ast;
end
}

Acces -> point identificateur #inh AppelOuAcces #ast;
#inh{
local
    t : Type;
    c : Classe;
    i : Interface;
    s : String;
    d : Declaration;
	o : Optional<Declaration>;
	a : Attribut;
	sf : StaticField;
    p : Parametre;
do
    s := nil;
    a := nil;
    sf := nil;
    AppelOuAcces^fromAcces := true;
	AppelOuAcces^identificateur_type := nil;
	AppelOuAcces^identificateur := identificateur^txt;
    match Acces^support
    with ParametreUseImpl then
        p := Acces^support.getParametre();
        if p.getName() = "this" then
            s := Acces^nomClasse;
        end
    end
    if s = nil then
        t := Acces^support.getTypeReel();
        match t
        with ClassTypeImpl then
            c := t.getClasse();
            s := c.getName();
        with InterfaceTypeImpl then
            i := t.getInterface();
            s := i.getName();
        else
            error(Acces_idend_ap0ac, "s bad initialized");
        end
    end
    AppelOuAcces^support := Acces^support;
    AppelOuAcces^nomClasse := s;
end
}
#ast{
do
	Acces^ast := AppelOuAcces^ast;
end
}

Acces ->  #ast;
#ast{
do
	Acces^ast := Acces^support;
end
}

Acces -> crochet_ouvrant Expression crochet_fermant #inh  Acces #ast;
#inh{
do
	Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}

#ast{
do
	Acces^ast := Acces1^ast;
end
}

Appel -> Arguments #inh Acces #ast;
#inh{
local
	o : Optional<Methode>;
	m : Methode;
	t : Type;
	c : Classe;
	i : Interface;
	s : String;
    d : Declaration;
    od : Optional<Declaration>;
    pu : Expression;
do
	o := nil;
	if Appel^fromFacteur then
		o := Appel^tdsMethodes.getMethode(Appel^identificateur, Appel^nomClasse, Arguments^ast);
	else
		t := Appel^support.getTypeReel();
		match t 
			with ClassTypeImpl then 
					c := t.getClasse(); 
					s := c.getName();
					o := Appel^tdsMethodes.getMethode(Appel^identificateur, s, Arguments^ast);
                    
			else 
					error (NOT_AN_OBJECT, t.toString());
		end
	end

	if o.isPresent() then
		m := o.get();
        if !Appel^fromFacteur then
             if (m.getDroitAcces() = DroitAcces.publique) && !m.isStatic() then
				Acces^support := Appel^factory.createAppel(Appel^support, m, Arguments^ast);
			 elseif m.isStatic() then
				match Appel^support
					with ClasseUseImpl then 
						Acces^support := Appel^factory.createAppel(Appel^support, m, Arguments^ast);
					else
						error(ACCESS_FORBIDDEN, " You must acces a static method through The class");
				end
			else
				error(ACCESS_FORBIDDEN, " Acces to a private or a protected method is forbidden");
			end
        else
            if !m.isStatic() then
                pu := nil;
                od := Appel^tds.get("this");
                d := od.get();
                match d
                with Parametre then
                    pu := Appel^factory.createParametreUse(d);
                end
                Acces^support := Appel^factory.createAppel(pu, m, Arguments^ast);
            else
                Acces^support := Appel^factory.createAppel(m, Arguments^ast);
            end
        end
	else
		error (UNDEFINED_METHOD_OR_SIGNATURE_OR_ATTRIBUT_OR_VARIABLE, " : " + Appel^identificateur);
	end
    Acces^fromAcces := false;

end
}
#ast{
do
	Appel^ast := Acces^ast;
end
}





-- DEJA FAIT

Comparatif -> egalite #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Equals;
end
}



Comparatif -> different #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Different;   
end  
}
  
Comparatif -> inferieur #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
  
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
  
Comparatif -> superieur #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

 

Additif -> addition #ast;  
#ast { 
do  
   Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
Additif -> ou #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Or;   
end  
}  



Multiplicatif -> multiplication #ast; 
#ast {
do 
   Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
   Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.And;   
end 
} 


Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);
end
}

Valeur -> caractere #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createCharValue(caractere^txt);
end
}

 

---------------------------------------------------------------------------------

Genericite -> inferieur #inh ParametresGenericite superieur  #ast ;
#inh{
do
	ParametresGenericite^tds := new SymbolTable();
end
}
#ast {
do
    Genericite^ast := ParametresGenericite^ast;
end
}

Genericite -> #ast;
#ast {
do
    Genericite^ast := new LinkedList<ParametreGenericite>();
end
}


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite #ast;
#ast {
do
	if ParametresGenericite^tds.contains(ParametreGenericite^ast.getName()) then
    	error(ParametreGenericite_aready_declared,ParametreGenericite^ast.getName());
	else
    	SuiteParametresGenericite^ast.addFirst(ParametreGenericite^ast);
    	ParametresGenericite^ast := SuiteParametresGenericite^ast;
    	ParametresGenericite^tds.register(ParametreGenericite^ast);
		--ParametresGenericite^tdsGenericite.register(ParametreGenericite^ast);
	end
end
}

SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite #ast;
#ast {
do
	if SuiteParametresGenericite^tds.contains(ParametreGenericite^ast.getName()) then
    	error(ParametreGenericite_aready_declared,ParametreGenericite^ast.getName());
	else
		SuiteParametresGenericite1^ast.addFirst(ParametreGenericite^ast);
    	SuiteParametresGenericite^ast := SuiteParametresGenericite1^ast;
    	SuiteParametresGenericite^tds.register(ParametreGenericite^ast);
		--SuiteParametresGenericite^tdsGenericite.register(ParametreGenericite^ast);
	end
end
}


SuiteParametresGenericite -> #ast;
#ast {
do
    SuiteParametresGenericite^ast := new LinkedList<ParametreGenericite>();
end
}


ParametreGenericite -> identificateur_type HeritageGenericite #ast;
#ast{
do
	ParametreGenericite^ast := ParametreGenericite^factory.createParametreGenericite(identificateur_type^txt, HeritageGenericite^ast);
end
}

 
ParametreGenericite -> choix HeritageGenericite #ast;
#ast{
do
	ParametreGenericite^ast := ParametreGenericite^factory.createParametreGenericite(HeritageGenericite^ast);
end
}


HeritageGenericite -> extension identificateur_type InstanceGenericite SuiteHeritageGenericite #ast;
#ast{
local
    f : Optional<Declaration>;
    d : Declaration;
do
	if HeritageGenericite^tdsClasses.contains(identificateur_type^txt) then
		f := HeritageGenericite^tdsClasses.get(identificateur_type^txt);
        d := f.get();
		match d
            with Classe then
                SuiteHeritageGenericite^ast.addFirst(d.getType());
                HeritageGenericite^ast := SuiteHeritageGenericite^ast;
            else
                error(BLOC_not_an_object, identificateur_type^txt);
            end
	elseif HeritageGenericite^tdsInterface.contains(identificateur_type^txt) then
		f := HeritageGenericite^tdsInterface.get(identificateur_type^txt);
        d := f.get();
		match d
            with Interface then
                SuiteHeritageGenericite^ast.addFirst(d.getType());
                HeritageGenericite^ast := SuiteHeritageGenericite^ast;
            else
                error(BLOC_not_an_object, identificateur_type^txt);
            end
	else
		error(CLASS_undefined_ident, identificateur_type^txt);
	end
end
}

HeritageGenericite ->  #ast;
#ast {
do
    HeritageGenericite^ast := nil;
end
}

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite #ast;
#ast{
local
	f : Optional<Declaration>;
	d : Declaration;
do
	if SuiteHeritageGenericite^tdsClasses.contains(identificateur_type^txt) then
		f := SuiteHeritageGenericite^tdsClasses.get(identificateur_type^txt);
        d := f.get();
		match d
            with Classe then
                SuiteHeritageGenericite1^ast.addFirst(d.getType());
                SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
            else
                error(BLOC_not_an_object, identificateur_type^txt);
            end
	elseif SuiteHeritageGenericite^tdsInterface.contains(identificateur_type^txt) then
		f := SuiteHeritageGenericite^tdsInterface.get(identificateur_type^txt);
        d := f.get();
		match d
            with Interface then
                SuiteHeritageGenericite1^ast.addFirst(d.getType());
                SuiteHeritageGenericite^ast := SuiteHeritageGenericite1^ast;
            else
                error(BLOC_not_an_object, identificateur_type^txt);
            end
	else
		error(CLASS_undefined_ident, identificateur_type^txt);
	end
end
}

SuiteHeritageGenericite -> #ast;
#ast {
do
    SuiteHeritageGenericite^ast := new LinkedList<Type>();
end
}

InstanceGenericite -> #ast;
#ast {
do
    InstanceGenericite^ast := nil;
end
}

InstanceGenericite -> inferieur ArgumentsGenericite superieur #ast;
#ast {
do
    InstanceGenericite^ast := ArgumentsGenericite^ast;
end
}


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite #ast;
#ast {
do
    SuiteArgumentsGenericite^ast.addFirst(ArgumentGenericite^ast);
    ArgumentsGenericite^ast := SuiteArgumentsGenericite^ast;
end
}


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite #ast;
#ast {
do
    SuiteArgumentsGenericite1^ast.addFirst(ArgumentGenericite^ast);
    SuiteArgumentsGenericite^ast := SuiteArgumentsGenericite1^ast;
end
}

SuiteArgumentsGenericite -> #ast;
#ast {
do
    SuiteArgumentsGenericite^ast := new LinkedList<ObjetUse>();
end
}


ArgumentGenericite -> identificateur_type InstanceGenericite #ast;
#ast{
local
	f : Optional<Declaration>;
	d : Declaration;
do
	if ArgumentGenericite^tdsClasses.contains(identificateur_type^txt) then
		f := ArgumentGenericite^tdsClasses.get(identificateur_type^txt);
        d := f.get();
		match d
            with Classe then
				if InstanceGenericite^ast = nil then
                	ArgumentGenericite^ast := ArgumentGenericite^factory.createClasseUse(d);
            	else
                	ArgumentGenericite^ast := ArgumentGenericite^factory.createClasseUse(d, InstanceGenericite^ast);
				end
            else
                error(BLOC_not_an_object, identificateur_type^txt);
            end
	elseif ArgumentGenericite^tdsInterface.contains(identificateur_type^txt) then
		f := ArgumentGenericite^tdsInterface.get(identificateur_type^txt);
        d := f.get();
		match d
            with Interface then
                if InstanceGenericite^ast = nil then
                	ArgumentGenericite^ast := ArgumentGenericite^factory.createInterfaceUse(d);
            	else
                	ArgumentGenericite^ast := ArgumentGenericite^factory.createInterfaceUse(d, InstanceGenericite^ast);
				end
            else
                error(BLOC_not_an_object, identificateur_type^txt);
            end
	else
		error(CLASS_undefined_ident, identificateur_type^txt);
	end
end
}

ArgumentGenericite -> type_String #ast;
#ast{
local
	f : Optional<Declaration>;
	d : Declaration;
do
	if ArgumentGenericite^tdsClasses.contains("String") then
		f := ArgumentGenericite^tdsClasses.get("String");
        d := f.get();
		match d
            with Classe then
                ArgumentGenericite^ast := ArgumentGenericite^factory.createClasseUse(d);
            else
                error(CLASS_not_an_object, " String");
            end
	else
		error(CLASS_undefined_ident, " String");
	end
end
}

end
